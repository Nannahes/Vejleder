library("imputeTS")
library('astsa')
library('readxl')
library('dplyr')
library('forecast')
library('TSA')
library('zoo')
library("MTS")
library("lubridate")


Daglig_data <- read_excel("C:/Users/Bruger/Dropbox/Min computer (DESKTOP-958HVSH)/Desktop/210215 Datagrundlag - Daglig forecast - projekt 1(uændret).xlsx", 
                          sheet = "Data", skip = 1)


################################################################### 830345 NettoDK
Daglig_830345 <- Daglig_data %>% filter(Kunde == "NettoDK",Vare=="830345")
Daglig_830345 <- Daglig_830345[order(as.Date(Daglig_830345$Dato, format="%Y/%m/%d")),]

#Salgvektorer
Salg_830345 <-  ts(Daglig_830345$SalgKolli, frequency = 365, start = c(2019, 1)); 
Salg_830345 <- na.interpolation(Salg_830345) #Erstatter NA med gennemsnit af værdien før og efter.

lSalg_830345 <- log(Salg_830345)
lSalg_830345 <- na.interpolation(lSalg_830345)

#Plot salg 
plot.ts(Salg_830345, type='l', main = "830345 NettoDK", ylab = "Salg", xlab= "Dato")
plot.ts(log(Salg_830345), type='l', main = "830345 NettoDK", ylab = "Salg", xlab= "Dato")
plot.ts(diff(Salg_830345), type='l', main = "830345 NettoDK", ylab = "Salg", xlab= "Dato")
#Dato vektor
dato.830345 <- Daglig_830345$Dato; dato.830345

#Prognose
Prog_ejkamp_830345 <-ts(Daglig_830345$ProgKolliEjKamp, frequency = 365, start = c(2019, 1)) #Alm. prognose
Prog_kamp_830345 <- ts(Daglig_830345$ProgKolliKamp, frequency = 365, start = c(2019, 1)) #Prognose kamp.
Prog_kamp_830345 <- na_interpolation(Prog_kamp_830345)
Prog_830345 <- Prog_ejkamp_830345 + Prog_kamp_830345; Prog_830345
lProg_830345 <- log(Prog_830345)
repinf = which(lProg_830345==-Inf);repinf
lProg_830345 <- replace(lProg_830345,repinf, c(rep(NaN, length(repinf))))
lProg_830345 <- na_interpolation(lProg_830345)

plot.ts(Prog_830345, type='l', main = "830345 NettoDK", ylab = "Salg", xlab= "Dato") # Plot af prognosen fra Danp0
#Plot prognose og salg i samme plot 
ts.830345 <- cbind(Prog_830345, Salg_830345)
plot.ts(ts.830345, plot.type = "single", col = c("green","black"), 
        ylab = "Salg og prognose", main="830345 NettoDK")
legend("topleft", legend=c("Realised Sale", "Forecasted Sale"),
       col=c("black", "green"), lty=1:2, cex=0.8)
as.numeric(time(log(Salg_830345)))#Indeks 391 bestemmes. Det er her vi starter tidsrækken fra
abline(v=2020.068,col="red")# Linjen på plottet viser, hvornår vi starter vores analyse

#Datasættet forkortes på grund af de knap så præcise prognoser i starten af tidsrækken
ts.830345.shorter <- ts(cbind(Prog_830345[391:762], Salg_830345[391:762]), frequency = 365, start =c(2020,26))
plot.ts(ts.830345.shorter, plot.type = "single", col = c("green","black"), 
        ylab = "Salg og prognose", main="830345 NettoDK")
legend("topleft", legend=c("Realised Sale", "Forecasted Sale"),
       col=c("black", "green"), lty=1:2, cex=0.6)
# Definer Salg og Prognose for den kortere periode
salg.830345_ts <- ts(lSalg_830345[391:762], frequency = 365, start =c(2020,26))
prog.830345_ts <- ts(lProg_830345[391:762], frequency = 365, start =c(2020,26))

# Bestem Transfer funktions model 
arimax.830345 = auto.arima(salg.830345_ts, # specify main trend
                           xreg = prog.830345_ts, # specify exogenous variables here
                           #ic="aicc",
                           trace = FALSE, # do not show fitted models  
                           seasonal= FALSE, # do not allow a SARIMAX model
                           stepwise= FALSE,
                           approximation=FALSE
)
arimax.830345
tsdiag(arimax.830345)
checkresiduals(arimax.830345)

### Forecast fra transfer funktion modellen ###
myforecasts.830345.actual <- forecast::forecast(arimax.830345, xreg=salg.830345_ts[(length(salg.830345_ts)-20):length(salg.830345_ts)],level =95);myforecasts.830345.actual
length(myforecasts.830345.actual$mean) # Bare for at sikre, at kun 21 perioder forekastes

plot(myforecasts.830345.actual) # Plot af tidsrækken med forecastede værdier og 95% confidence bands
# Nærbillede af de forecastede værdier 
plot(myforecasts.830345.actual,xlim=c(2020.8,2021.15))


#######################################################################
                        #PREWHITENING
#######################################################################
############ testsæt ################################
#Time series 
salg.830345_ts <- ts(log(Salg_830345), frequency = 365, start =c(2019,1))
prog.830345_ts <- ts(lProg_830345, frequency = 365, start =c(2019,1))

#Split data til train og test sæt. Vi fjerner de første, da prognosen er dårlig.
salg.830345_train <- window(salg.830345_ts,start=c(2020,25), end=c(2020,365))
salg.830345_test <- window(salg.830345_ts, start=c(2021,0))

prog.830345_train <- window(prog.830345_ts,start=c(2020,25), end=c(2020,365))
prog.830345_test <- window(prog.830345_ts, start=c(2021,0))
########################################################

########## Tjek CCF ####################################
ccf2(as.vector(salg.830345_train),as.vector(prog.830345_train))
#Der er korolationer, så prewhiten. 

#################### Prewhitening #######################
#Først skal input-tidsrækken mean korregeres:
new.prog.830345 = prog.830345_train - mean(prog.830345_train)

#Herefter bestemmes en arima for input-tidsrækken:
input.model.830345 = auto.arima(new.prog.830345, trace=TRUE);
input.model.830345 #(2,0,0)
#Modeltjek
tsdiag(input.model.830345)
checkresiduals(input.model.830345)

##########################  Prewhiten  ##################
#Gem relevante coefficienter fra modellen 
ar1.830345 =-input.model.830345$coef[1]; ar1.830345
ar2.830345 =-input.model.830345$coef[2]; ar2.830345

#Man prewhitener ved at filtrerer - først prewhitnes output serien
pw.salg.830345 = stats::filter(salg.830345_train,filter = c(1,ar1.830345,ar2.830345),
                               #method = "recursive",
                               sides=1)
pw.salg.830345 = pw.salg.830345[3:341] #pre-whitened salg

#Prewhitend prognose burde være residualerne af modellen, så
pw.prog.830345 =input.model.830345$residuals; pw.prog.830345
#Som burde være det samme, som hvis man filtrerer
filt.prog.830345 = stats::filter(new.prog.830345,filter=c(1,ar1.830345,ar2.830345),
                                 #method=c("recursive"),
                                 sides=1)
filt.prog.830345 = filt.prog.830345[3:341] #De første inputs er NA
#Jeps, man får det samme ved at filtrerer, som når man tager residualerne. 

############ Tjek prewhitened CCF
ccf2(as.vector(pw.salg.830345),as.vector(filt.prog.830345))
#Denne CCF er en del pænere, men stadig ideel

###############################################################
                    #FORECASTING
###############################################################
#HVORDAN KOMMER VI VIDERE MED AT FORECASE UD FRA DEN PREWHITENEDE DATA?
